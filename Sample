import Foundation

struct WeatherForecast: Codable {
    let location: String
    let temperature: [String: Double]
    let weatherDescription: [String: String]
    // Define other relevant fields based on the API response
}import Foundation
import Alamofire

class NetworkManager {
    static let shared = NetworkManager()
    private init() {}

    let apiKey = "YOUR_API_KEY"
    let baseURL = "https://my.meteoblue.com/api/v1/forecast/"

    func getWeatherForecast(for location: String, completion: @escaping (Result<WeatherForecast, Error>) -> Void) {
        let endpoint = "\(baseURL)\(location)"
        let parameters: [String: Any] = ["apikey": apiKey]
        
        AF.request(endpoint, parameters: parameters).responseData { response in
            switch response.result {
            case .success(let data):
                do {
                    let decoder = JSONDecoder()
                    let forecast = try decoder.decode(WeatherForecast.self, from: data)
                    completion(.success(forecast))
                } catch {
                    completion(.failure(error))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }
}
nt 1",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 61,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 7777
    ],
    [
        "attributeId": "Branch",
        "averagebollWeight": nil,
        "averagebollWeightUnit": nil,
        "branch": 21,
        "captureTime": "1718187866.480301",
        "date": "2024-06-12",
        "distanceBetweenRow": nil,
        "distanceBetweenRowUnit": nil,
        "fieldId": 91,
        "numberOfPlants": nil,
        "plant": "Plant 1",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 62,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 7
    ],
    [
        "attributeId": "Branch",
        "averagebollWeight": nil,
        "averagebollWeightUnit": nil,
        "branch": 1,
        "captureTime": "1718187866.480301",
        "date": "2024-06-12",
        "distanceBetweenRow": nil,
        "distanceBetweenRowUnit": nil,
        "fieldId": 91,
        "numberOfPlants": nil,
        "plant": "Plant 5",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 61,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 98
    ],
    [
        "attributeId": "Branch",
        "averagebollWeight": nil,
        "averagebollWeightUnit": nil,
        "branch": 4,
        "captureTime": "1718187866.480301",
        "date": "2024-06-12",
        "distanceBetweenRow": nil,
        "distanceBetweenRowUnit": nil,
        "fieldId": 91,
        "numberOfPlants": nil,
        "plant": "Plant 3",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 62,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 111
    ]
]
import Foundation

struct Attribute: Codable {
    var plot_data_id: String?
    var attribute_id: String
    var attribute_unit1_id: String?
    var attribute_unit2_id: String?
    var quantity: String?
}

struct Plant: Codable {
    var id: String?
    var plant_no: Int
    var branch: Int
    var branch_type: Int
    var p1_value: Int
    var p2_value: Int
    var p3_value: Int
}

struct PlotInfo: Codable {
    var plot_id: String
    var sub_plot: String
    var attributes: [Attribute]
    var plants: [Plant]
}

struct CollectData: Codable {
    var sampling_date: String
    var sub_sample_count: String
    var plot_info: [PlotInfo]
}

struct Data: Codable {
    var template_id: String
    var collect_data: [CollectData]
}

struct FieldData: Codable {
    var field_id: String
    var data: [Data]
}
func convertCoreDataModelToDictionary(coreDataArray: [[String: Any]]) -> [String: Any]? {
    guard let firstData = coreDataArray.first else { return nil }
    let field_id = String(firstData["fieldId"] as? Int ?? 0)
    let template_id = String(firstData["templateId"] as? Int ?? 0)
    let date = firstData["date"] as? String ?? ""

    // Group entries by plotId
    var plotInfoDictionary: [String: [String: Any]] = [:]

    for coreData in coreDataArray {
        let plot_id = String(coreData["plotId"] as? Int ?? 0)
        let branch = coreData["branch"] as? Int ?? 0
        let value = coreData["value"] as? Int ?? 0
        let plant = coreData["plant"] as? String ?? ""
        
        // Extract plant number by removing the prefix "Plant " and converting to Int
        let plantNoString = plant.replacingOccurrences(of: "Plant ", with: "")
        let plantNo = Int(plantNoString) ?? 0

        let plantObject: [String: Any] = [
            "id": nil as Any?,
            "plant_no": plantNo,
            "branch": branch,
            "branch_type": 1,
            "p1_value": 0,
            "p2_value": value,
            "p3_value": 0
        ]

        if plotInfoDictionary[plot_id] == nil {
            // Create a new PlotInfo entry if it doesn't exist
            let attributes: [[String: Any]] = [
                ["plot_data_id": nil as Any?, "attribute_id": "72", "attribute_unit1_id": nil as Any?, "attribute_unit2_id": nil as Any?, "quantity": nil as Any?],
                ["plot_data_id": nil as Any?, "attribute_id": "73", "attribute_unit1_id": nil as Any?, "attribute_unit2_id": nil as Any?, "quantity": nil as Any?],
                ["plot_data_id": nil as Any?, "attribute_id": "74", "attribute_unit1_id": nil as Any?, "attribute_unit2_id": nil as Any?, "quantity": nil as Any?],
                ["plot_data_id": nil as Any?, "attribute_id": "75", "attribute_unit1_id": nil as Any?, "attribute_unit2_id": nil as Any?, "quantity": nil as Any?]
            ]
            plotInfoDictionary[plot_id] = [
                "plot_id": plot_id,
                "sub_plot": "",
                "attributes": attributes,
                "plants": [plantObject]
            ]
        } else {
            // Append the plant to the existing PlotInfo entry
            var existingPlotInfo = plotInfoDictionary[plot_id]
            var existingPlants = existingPlotInfo?["plants"] as? [[String: Any]] ?? []
            existingPlants.append(plantObject)
            existingPlotInfo?["plants"] = existingPlants
            plotInfoDictionary[plot_id] = existingPlotInfo!
        }
    }

    // Convert dictionary to array
    let plotInfoArray = Array(plotInfoDictionary.values)
    let collectData: [String: Any] = [
        "sampling_date": date,
        "sub_sample_count": "",
        "plot_info": plotInfoArray
    ]
    let data: [String: Any] = [
        "template_id": template_id,
        "collect_data": [collectData]
    ]
    let fieldData: [String: Any] = [
        "field_id": field_id,
        "data": [data]
    ]

    return fieldData
}
}

let coreDataModels: [[String: Any]] = [
    [
        "attributeId": "Branch",
        "averagebollWeight": nil,
        "averagebollWeightUnit": nil,
        "branch": 20,
        "captureTime": "1718187866.480301",
        "date": "2024-06-12",
        "distanceBetweenRow": nil,
        "distanceBetweenRowUnit": nil,
        "fieldId": 91,
        "numberOfPlants": nil,
        "plant": "Plant 1",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 61,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 7777
    ],
    [
        "attributeId": "Branch",
        "averagebollWeight": nil,
        "averagebollWeightUnit": nil,
        "branch": 21,
        "captureTime": "1718187866.480301",
        "date": "2024-06-12",
        "distanceBetweenRow": nil,
        "distanceBetweenRowUnit": nil,
        "fieldId": 91,
        "numberOfPlants": nil,
        "plant": "Plant 1",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 62,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 7
    ],
    [
        "attributeId": "Branch",
        "averagebollWeight": nil,
        "averagebollWeightUnit": nil,
        "branch": 1,
        "captureTime": "1718187866.480301",
        "date": "2024-06-12",
        "distanceBetweenRow": nil,
        "distanceBetweenRowUnit": nil,
        "fieldId": 91,
        "numberOfPlants": nil,
        "plant": "Plant 5",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 61,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 98
    ],
    [
        "attributeId": "Branch",
        "averagebollWeight": nil,
        "averagebollWeightUnit": nil,
        "branch": 4,
        "captureTime": "1718187866.480301",
        "date": "2024-06-12",
        "distanceBetweenRow": nil,
        "distanceBetweenRowUnit": nil,
        "fieldId": 91,
        "numberOfPlants": nil,
        "plant": "Plant 3",
        "plantDistanceRow": nil,
        "plantDistanceRowUnit": nil,
        "plants": nil,
        "plotDataId": "Branch",
        "plotId": 62,
        "templateId": 10,
        "uploadStatus": "0.0",
        "userId": 1,
        "value": 111
    ]
]

if let jsonString = convertCoreDataModelToJSON(coreDataArray: coreDataModels) {
    print(jsonString)
}
import UIKit

class WeatherViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()

        NetworkManager.shared.getWeatherForecast(for: "Zurich") { result in
            switch result {
            case .success(let forecast):
                print("Weather Forecast: \(forecast)")
                // Update your UI with the forecast data
            case .failure(let error):
                print("Error fetching weather forecast: \(error)")
                // Handle the error (e.g., show an alert to the user)
            }
        }
    }
}

import IOKit.usb

func listUSBDevices() {
    let matchingDict = IOServiceMatching(kIOUSBDeviceClassName)
    var iterator: io_iterator_t = 0

    let result = IOServiceGetMatchingServices(kIOMasterPortDefault, matchingDict, &iterator)
    if result == kIOReturnSuccess {
        var device: io_object_t
        while (device = IOIteratorNext(iterator), device != 0) {
            if let cfVendorID = IORegistryEntryCreateCFProperty(device, "idVendor" as CFString, kCFAllocatorDefault, 0)?.takeRetainedValue() as? NSNumber,
               let cfProductID = IORegistryEntryCreateCFProperty(device, "idProduct" as CFString, kCFAllocatorDefault, 0)?.takeRetainedValue() as? NSNumber {
                print("Vendor ID: \(cfVendorID), Product ID: \(cfProductID)")
            }
            IOObjectRelease(device)
        }
    }
    IOObjectRelease(iterator)
}

listUSBDevices()



@IBAction func sendCommandButtonClicked(_ sender: NSButton) {
    let hexCommand = "AA00810401001001842B100182013CA3098101018201018301018402000386159C01009F0206000000000000"

    guard let jsContext = jsContext else { return }
    let sendCommand = jsContext.objectForKeyedSubscript("sendDynaflexCommand")
    
    let promise = sendCommand?.call(withArguments: [hexCommand])
    
    jsContext.evaluateScript("""
    async function handlePromise(promise) {
        try {
            const result = await promise;
            return result;
        } catch (error) {
            return `Error: ${error.message}`;
        }
    }
    """)

    let handlePromise = jsContext.objectForKeyedSubscript("handlePromise")
    if let resolvedResult = handlePromise?.call(withArguments: [promise])?.toString() {
        print("Resolved Response:", resolvedResult)
    }
}




import Cocoa
import JavaScriptCore

class ViewController: NSViewController {
    var jsContext: JSContext?

    override func viewDidLoad() {
        super.viewDidLoad()

        // Initialize JavaScript context
        jsContext = JSContext()
        loadJavaScriptCode()
    }

    func loadJavaScriptCode() {
        guard let jsContext = jsContext else { return }

        // Add JavaScript code to context
        let jsCode = """
        \(your JavaScript code as a string)
        """
        jsContext.evaluateScript(jsCode)
    }

    @IBAction func sendCommandButtonClicked(_ sender: NSButton) {
        let hexCommand = "AA00810401001001842B100182013CA3098101018201018301018402000386159C01009F0206000000000000"

        guard let jsContext = jsContext else { return }
        let sendCommand = jsContext.objectForKeyedSubscript("sendDynaflexCommand")
        let result = sendCommand?.call(withArguments: [hexCommand])

        if let response = result?.toString() {
            print("Response from JS:", response)
        }
    }
}




let jsCode = """
async function sendDynaflexCommand(hexCommand) {
    try {
        const devices = await navigator.hid.requestDevice({
            filters: [{ vendorId: 0x0801, productId: 0x2020 }]
        });

        if (devices.length === 0) return "No devices found";

        const device = devices[0];
        await device.open();

        const bytes = hexToBytes(hexCommand);
        const reportID = 0x00;

        await device.sendReport(reportID, new Uint8Array(bytes));

        device.addEventListener("inputreport", (event) => {
            const data = new Uint8Array(event.data.buffer);
            console.log("Received:", data);
        });

        return "Command sent successfully";
    } catch (error) {
        console.error(error);
        return `Error: ${error.message}`;
    }
}

function hexToBytes(hex) {
    const bytes = [];
    for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.substring(i, i + 2), 16));
    }
    while (bytes.length < 64) {
        bytes.push(0x00);
    }
    return bytes;
}
"""

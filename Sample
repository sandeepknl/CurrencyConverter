To open a local HTML file in a macOS application using Google Chrome programmatically, you can use Swift and the Process class to invoke the open command. Here’s a straightforward way to do it:

Code Example in Swift

import Cocoa

func openHTMLInChrome(filePath: String) {
    // Get the full file URL
    let fileURL = URL(fileURLWithPath: filePath)
    
    // Check if Google Chrome is installed
    let chromeAppPath = "/Applications/Google Chrome.app"
    guard FileManager.default.fileExists(atPath: chromeAppPath) else {
        print("Google Chrome is not installed.")
        return
    }
    
    // Use `open` command to launch the file in Chrome
    let process = Process()
    process.launchPath = "/usr/bin/open"
    process.arguments = ["-a", "Google Chrome", fileURL.path]
    process.launch()
}

// Example usage:
let htmlFilePath = "/path/to/your/file.html" // Replace with your HTML file path
openHTMLInChrome(filePath: htmlFilePath)

Steps to Integrate This into Your macOS App
	1.	Add the function openHTMLInChrome(filePath:) to your project.
	2.	Call the function wherever needed, passing the full path to the local HTML file you want to open.

How It Works
	1.	Locate the HTML file:
	•	Use the fileURLWithPath initializer to create a URL for the HTML file.
	2.	Verify Chrome installation:
	•	Check if Chrome is present at /Applications/Google Chrome.app.
	3.	Run the open command:
	•	Use the Process class to invoke the open command with -a "Google Chrome" to specify the app.

Alternate: Default Browser Option

If you want the HTML file to open in the user’s default browser instead of Chrome:

import Cocoa

func openHTMLInDefaultBrowser(filePath: String) {
    let fileURL = URL(fileURLWithPath: filePath)
    NSWorkspace.shared.open(fileURL)
}

// Example usage:
let htmlFilePath = "/path/to/your/file.html"
openHTMLInDefaultBrowser(filePath: htmlFilePath)

This method will automatically use the user’s default browser (which could still be Chrome if set as the default).

Let me know if you need further clarification!




If your HTML works fine in Chrome but not in Safari, and you want to make it work in a macOS app using WKWebView (Safari’s WebKit engine), here are some steps to troubleshoot and work around the issue:

1. Understand the Compatibility Issue
	•	Inspect your HTML/CSS/JavaScript:
	•	Check for features that are supported in Chrome but not in Safari. Use tools like Can I Use to identify feature support for Safari.
	•	Common issues may include:
	•	Use of experimental JavaScript features (e.g., ES2022).
	•	CSS properties or values unsupported in Safari.
	•	Web APIs exclusive to Chrome.
	•	Use Safari Developer Tools:
	•	Open your HTML in Safari and check for errors in the Web Inspector (Develop > Show Web Inspector).
	•	This will often reveal JavaScript errors or unsupported features.

2. Enable WebKit Experimental Features

Safari’s WebKit engine has experimental features that you can enable in WKWebView to improve compatibility.

Example:

Enable these features in your WKWebView configuration:

import Cocoa
import WebKit

class ViewController: NSViewController {

    var webView: WKWebView!

    override func viewDidLoad() {
        super.viewDidLoad()

        // WKWebView configuration
        let config = WKWebViewConfiguration()
        config.preferences.setValue(true, forKey: "developerExtrasEnabled") // Enable developer tools
        config.preferences.setValue(true, forKey: "javaScriptEnabled") // Ensure JavaScript is enabled
        config.preferences.setValue(true, forKey: "javaScriptCanOpenWindowsAutomatically") // Allow popups

        // WebView
        webView = WKWebView(frame: self.view.bounds, configuration: config)
        webView.autoresizingMask = [.width, .height]
        self.view.addSubview(webView)

        // Load your HTML
        if let url = URL(string: "https://your-chrome-supported-html.com") {
            webView.load(URLRequest(url: url))
        }
    }
}

3. Use Polyfills or Libraries

To support Safari’s WebKit engine, you may need to use polyfills for unsupported features.

Example:
	•	Use Babel for JavaScript transpiling to ensure compatibility.
	•	Include a polyfill like core-js to enable missing browser features:

<script src="https://cdn.jsdelivr.net/npm/core-js-bundle@3.6.5/minified.js"></script>

4. Serve a Chrome-Specific Experience

If you’re hosting your HTML, you can detect the user agent and serve Safari-specific fixes.

Example: Detecting Safari in JavaScript

if (navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")) {
    // Apply Safari-specific fixes
    console.log("You're using Safari!");
}

Example: In HTML with WKWebView

You can modify the user agent in WKWebView to request a Chrome-like experience:

config.applicationNameForUserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"

5. Try WKWebView’s Chromium-Based Alternative

If you cannot resolve the compatibility issues, consider embedding Chromium directly using:
	1.	CEF (Chromium Embedded Framework): A full Chromium rendering engine.
	•	This will ensure full Chrome compatibility.
	2.	Electron: Build your app as an Electron app, which uses Chromium.

6. Render HTML Locally

If your HTML is local (not hosted on a server), ensure all resources are accessible by WKWebView:

Example: Loading Local HTML in WKWebView

let htmlPath = Bundle.main.path(forResource: "index", ofType: "html")!
let htmlURL = URL(fileURLWithPath: htmlPath)
webView.loadFileURL(htmlURL, allowingReadAccessTo: htmlURL.deletingLastPathComponent())

7. Debug and Fix Specific Safari Issues

Safari-specific fixes might include:

CSS Issues:
	•	Use Safari-specific media queries or CSS hacks:

@supports (-webkit-touch-callout: none) {
    /* Safari-specific styles */
}



JavaScript Issues:
	•	For unsupported JavaScript APIs, check compatibility and use alternative approaches or polyfills.

Web APIs:
	•	Check for Safari compatibility for APIs like WebRTC, WebGL, or Web Animations API.

When to Use WKWebView or Chromium

Scenario	Recommendation
You can adapt your HTML for WebKit	Use WKWebView.
HTML relies heavily on Chrome-specific APIs	Use CEF or Electron.
You only need small patches for Safari	Use polyfills or feature detection.

If you’d like assistance fixing a specific compatibility issue or transitioning to a Chromium-based engine, let me know!



To integrate this JavaScript code into a macOS application and use two buttons from a storyboard to interact with the dynaflex device, follow these steps:

1. Set Up a macOS Application in Xcode
	•	Create a new macOS App project in Xcode.
	•	Add a WKWebView to your storyboard to run the JavaScript within the app.

2. Include the JavaScript Files
	•	Add all the JavaScript files (mt_utils.js, mt_mms.js, etc.) to your Xcode project. Ensure they are included in the app bundle.
	•	Use the WKWebView to load these scripts.

3. Storyboard Setup
	•	Add two buttons to your storyboard:
	•	Open Device button (openDeviceButton).
	•	Send Command button (sendCommandButton).
	•	Add a WKWebView to display or interact with logs/UI if needed.

4. Code Integration

In your ViewController.swift, load the JavaScript and handle button actions.

ViewController.swift

import Cocoa
import WebKit

class ViewController: NSViewController {
    @IBOutlet weak var webView: WKWebView!
    @IBOutlet weak var openDeviceButton: NSButton!
    @IBOutlet weak var sendCommandButton: NSButton!

    override func viewDidLoad() {
        super.viewDidLoad()

        // Configure WKWebView
        let config = WKWebViewConfiguration()
        webView = WKWebView(frame: .zero, configuration: config)
        view.addSubview(webView)
        webView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            webView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            webView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            webView.topAnchor.constraint(equalTo: view.topAnchor),
            webView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])

        // Load the HTML and JavaScript
        loadHTMLAndJavaScript()
    }

    func loadHTMLAndJavaScript() {
        // Path to your bundled HTML/JavaScript file
        if let htmlPath = Bundle.main.path(forResource: "index", ofType: "html") {
            let url = URL(fileURLWithPath: htmlPath)
            webView.loadFileURL(url, allowingReadAccessTo: url)
        }
    }

    // Handle Open Device Button
    @IBAction func openDeviceClicked(_ sender: NSButton) {
        webView.evaluateJavaScript("handleOpenButton()") { result, error in
            if let error = error {
                print("Error opening device: \(error)")
            } else {
                print("Device opened successfully.")
            }
        }
    }

    // Handle Send Command Button
    @IBAction func sendCommandClicked(_ sender: NSButton) {
        let command = "GETAPPVERSION" // Example command
        webView.evaluateJavaScript("parseCommand('\(command)')") { result, error in
            if let error = error {
                print("Error sending command: \(error)")
            } else {
                print("Command sent successfully: \(result ?? "")")
            }
        }
    }
}

5. Create an HTML File
	•	Create an index.html file that serves as the entry point for your WKWebView.
	•	Include all your JavaScript files in the <script> tags.

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynaflex Device</title>
</head>
<body>
    <h1>Dynaflex Device Interface</h1>
    <script src="mt_utils.js"></script>
    <script src="mt_mms.js"></script>
    <script src="mt_hid.js"></script>
    <script src="mt_ui.js"></script>
    <script src="mt_rms_mms.js"></script>
    <script src="mt_rms_api.js"></script>
    <script src="mt_events.js"></script>
</body>
</html>

6. Test the App
	•	Run the macOS app.
	•	Use the Open Device button to open the device and Send Command to send commands like GETAPPVERSION or others.

Notes:
	•	You may need to enable JavaScript in the WKWebView configuration.
	•	The index.html file and JavaScript files must be included in the app bundle.
	•	If the device interactions require native macOS APIs (e.g., USB communication), you might need to create a macOS-native layer that communicates with the JavaScript.

Let me know if you’d like detailed guidance on any of these steps!






        let tagByte = TagBuffer[0];
        let endIndex =
          iTLV + lengthValue > dataLength ? dataLength : iTLV + lengthValue;
        let len = endIndex - iTLV;
        let valueBytes =
          len > 0 ? toHexString(data.slice(iTLV, iTLV + len)) : "";
        result.push({
          tag: tagBytes,
          tagLength: !lengthValue ? valueBytes.length + 1 / 2 : lengthValue,
          tagValue: valueBytes,
        });
        if (!((tagByte & constructedFlag) == constructedFlag)) {
          iTLV += lengthValue;
        }
      }
      bTag = true;
    }
  }
  return result;
}

export function getTagValue(tagName, defaultTagValue, tlvData, asASCII) {
  try 
  {
    var TLVS = tlvParser(tlvData);
    var currtlv = TLVS.find((tlv) => tlv.tag === tagName);
    if (currtlv == undefined) return defaultTagValue;
    {
      if (asASCII == true) {
        return hexToASCIIRemoveNull(currtlv.tagValue);
      } 
      else 
      {
        return currtlv.tagValue;
      }
    }
  } 
  catch (error) {
    return defaultTagValue;
  }
  
}

export function removeSpaces(str) {
  return str.replace(/\s+/g, "");
}

export function hexToBytes(hex) {
  let bytes = [];
  for (let i = 0; i < hex.length; i += 2)
    bytes.push(parseInt(hex.substring(i, i+2), 16));
  return bytes;
}

export function debugLog(data) {
  // console.log(`DebugLog: ${data}`);
}

export function getDefaultValue(key, defaultValue){
  var keyVal = localStorage.getItem(key);
  if (keyVal == null) keyVal = defaultValue;
  return keyVal;
}

export function saveDefaultValue(key, value){
  localStorage.setItem(key, value);    
}

export function makeid(length) {
  let result = '';
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  const charactersLength = characters.length;
  let counter = 0;
  while (counter < length) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
    counter += 1;
  }
  return result;
}

export function filterString(inputString) {
	const filteredString = inputString.replace(/[^0-9A-Za-z]/g, '');
	return filteredString;
};



Array.prototype.zeroFill = function (len) {
  for (var i = this.length; i < len; i++) {
    this[i] = 0;
  }
  return this;
};


